# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LerPlusDockDockWidget
                                 A QGIS plugin
 Nem adgang til LER2 forespørgsler
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-10-09
        git sha              : $Format:%H$
        copyright            : (C) 2023 by qLER ApS
        email                : morten@qler.dk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtCore import QSettings, QSize
from qgis.PyQt.QtWidgets import QFrame, QMessageBox, QPushButton
from PyQt5.QtWidgets import QApplication, QMainWindow, QTableWidget, QTableWidgetItem, QPushButton, QVBoxLayout, QWidget, QComboBox, QProgressDialog
from qgis.PyQt.QtGui import QDesktopServices
from PyQt5.QtGui import QColor
from qgis.PyQt.QtCore import Qt, QUrl
#from .lerplus_settings import LERplusSettings
#from .lerplus_config import *
from .lerplus_utils import *
from datetime import datetime
from PyQt5.QtCore import QTimer
from functools import partial
from .lerplusnewsession import LERplusNewSession
import tempfile
import processing
import requests
from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject

#from .suggester import Suggester
#from .config import Settings


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'lerpluswidget.ui'))



class DateTableWidgetItem(QTableWidgetItem):
    def __init__(self, date_str, timestamp):
        super().__init__(date_str)
        self.timestamp = timestamp

    def __lt__(self, other):
        if isinstance(other, DateTableWidgetItem):
            return self.timestamp < other.timestamp
        return super().__lt__(other)

class LerPlusWidget(QFrame, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface):
        """Constructor."""
        QFrame.__init__(self, iface.mainWindow())
        #super(LerPlusWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        #self.readconfig()
        self.setupUi(self)
        self.iface = iface
        self.setFrameStyle(QFrame.StyledPanel + QFrame.Raised)

        #self.settings=settings
        #self.suggester = Suggester(
        #    settings=settings,
        #    searchbox_widget=self.searchEdit,
        #    notauthorized_func=self.handleNotAuthorized
        #)

        self.resize(50, self.height())
        #self.searchEdit.setFocus()
        self.settingsButton.clicked.connect(self.showSettings)
        self.newsessionButton.clicked.connect(self.newSession)
        self.updatenowButton.clicked.connect(lambda: self.updateSessions(True))

        self.timer = QTimer()
        self.timer.timeout.connect(self.updateSessions)
        self.timer.start(120000)  # 60 seconds in milliseconds

        self.resulttable.setColumnCount(12)
        self.resulttable.setHorizontalHeaderLabels(
            ['LER#', "Dato", "Lavet af", "Status", "Dele", "Ejere", "LER2", "-LER2",
             "Beskrivelse",   "Download", "Importér", "Kortviser"]) #"ZIP", "GML", "DGN",
        self.resulttable.setSortingEnabled(True)

        #self.readconfig()
        #self.updateSessions()
        self.checkToken()

        self.filterEdit.textChanged.connect(self.filterresulttable)

    def newSession(self):

        layer = self.iface.activeLayer()

        if layer is None:
            QMessageBox.about(self, "Fejl", "Ikke noget aktivt layer")
            return

        if not hasattr(layer, 'selectedFeatures'):
            QMessageBox.about(self, "Fejl", "Layer har ikke valgte features")
            return

        list = []

        for feature in layer.selectedFeatures():
            list.append(feature)

        if len(list) == 0:
            QMessageBox.about(self, "Fejl", "Ingen geometri valgt")
            return

        if len(list) > 1:
            QMessageBox.about(self, "Fejl", "Flere end 1 geometri valgt")
            return

        mypoly = list[0]
        geom = mypoly.geometry()


        wkt = str(geom.asWkt())
        if wkt.startswith("Polygon") is False:
            QMessageBox.about(self, "Fejl", "Den valgte geometri skal være POLYGON. Nu er den: " + wkt[0:20])
            return

        #QMessageBox.about(self, "Fejl", geom.asWkt())
        if layer.crs().authid() != 'EPSG:25832':
            source_crs = layer.crs()
            target_crs = QgsCoordinateReferenceSystem(25832)
            transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
            transformed_geom = geom.transform(transform)
            #QMessageBox.about(self, "Fejl", layer.crs().authid())
        # EPSG:4326
        # EPSG:25832



        #Point
        #LineString

        #QMessageBox.about(self, "Geometry", str(geom.asWkt()))

        self.newsession = LERplusNewSession()
        self.newsession.setIface(self.iface)
        self.newsession.setGeometry(geom)
        #self.newsession.setGeometry(str(geom.asWkt()))
        self.newsession.setupValues()
        self.newsession.exec_()

        return

    def filterresulttable(self):
        filter_text = self.filterEdit.text().lower()
        columns_to_filter = [0, 6]  # Indices of the columns to filter

        for row in range(self.resulttable.rowCount()):
            row_data = [self.resulttable.item(row, col).text().lower() if col in columns_to_filter else "" for col in
                        range(self.resulttable.columnCount())]
            if any(filter_text in cell_data for cell_data in row_data):
                self.resulttable.setRowHidden(row, False)
            else:
                self.resulttable.setRowHidden(row, True)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        self.timer.timeout.disconnect(self.updateSessions)
        event.accept()

    def setIface(self,iface):
        self.iface = iface

    def showSettings(self):
        self.iface.showOptionsDialog(currentPage="LER+")
        self.checkToken()
        #self.settings = LERplusSettings()
        #self.settings.setIface(self.iface)
        #self.settings.exec_()


    def checkToken(self):
        settings = QgsSettings()
        token = settings.value("lerplusdock/apitoken")
        # QMessageBox.information(self, 'Token', token)
        # QgsMessageLog.logMessage(token)
        if (token != "") and (token is not None):
            # QgsMessageLog.logMessage(token)
            # r = requests.get(f'https://backend.lerplus.dk/api/checktoken?apitoken={token}')
            #    if token is
            r = requests.get(API_URLBASE + '/checktoken?apitoken=' + token)

            if not is_valid_json(r.text):
                QMessageBox.information(self, 'Invalid API-response', r.text)
                return

            # QMessageBox.information(self, 'API-response', r.text)
            if r.status_code == 200:
                #self.apiStatusBox.setProperty("styleSheet", "background-color: rgb(0, 170, 0);")
                #self.apiStatusLabel.setProperty("text", "API forbundet")
                self.clientName.show()
                if settings.value("lerplus/debugmode") == 1:
                    QMessageBox.information(self, 'API-response', r.text)

                reply = json.loads(r.text)
                # QgsMessageLog.logMessage(reply['data']['client name'])

                self.clientName.setProperty("text", reply['data']['user name'] + ", " + reply['data']['client name'])
                if reply['data']['ler2ok'] == 1:
                    self.LER2Status.setProperty("text", "LER2-status: OK")
                    self.LER2Status.setStyleSheet("color:green")
                else:
                    self.LER2Status.setProperty("text", "LER2-status: Fejl: " + reply['data']['ler2error'])
                    self.LER2Status.setStyleSheet("color:red")

                if reply['data']['islive'] == 1:
                    self.clientIsLive.setProperty("text", "Miljø: LIVE")
                else:
                    self.clientIsLive.setProperty("text", "Miljø: EXTEST")

            else:
                # QgsMessageLog.logMessage(str(r.status_code))
               # self.apiStatusBox.setProperty("styleSheet", "background-color: rgb(170, 0, 0);")
              #  self.apiStatusLabel.setProperty("text", "API ikke forbundet")
                if settings.value("lerplus/debugmode") == 1:
                    QMessageBox.information(self, 'API-response', r.text)
                self.LER2Status.setProperty("text", "LER2-status: N/A")
                self.LER2Status.setStyleSheet("color:red")
                self.clientIsLive.setProperty("text", "Miljø: N/A")
                self.clientName.setProperty("text", "N/A")
                #self.clientName.hide()

    """
    def readconfig(self):
        self.settings = Settings() # new config
        # Old way was storing settings in global scope. Leave advanced options there for now
        s = QSettings()
        k = __package__

        # prefix muncodes
        #muncodes = re.findall(r'\d+', settings.value('kommunefilter'))
        #areafilter = ','.join(['muncode0'+str(k) for k in muncodes])

        self.config = {
            'apitoken' : self.settings.value('apitoken'),
            'debugmode': self.settings.value('debugmode'),
        }

    """

    def handleNotAuthorized(self):
        title = self.tr(u'Afvist af lerPLUS-backend')
        message = self.tr(u'Manglende eller ukorrekt token til LER+.')
        button_text = self.tr(u'Åbn indstillinger')
        widget = self.iface.messageBar().createMessage(title, message)
        button = QPushButton(widget)
        button.setText(button_text)
        button.pressed.connect(lambda : self.iface.showOptionsDialog(currentPage='LER+'))
        widget.layout().addWidget(button)
        self.iface.messageBar().pushWidget(widget, level=Qgis.Warning, duration=15)

    def getProgressBox(self, title, message):
        progress_dialog = QProgressDialog(message, None, 0, 0, self)
        progress_dialog.setWindowTitle(title)
        progress_dialog.setModal(True)
        progress_dialog.setCancelButton(None)
        progress_dialog.show()

        # Simulate a processing task
        QApplication.processEvents()
        return progress_dialog


    def updateSessions(self, force=False):
        # QMessageBox.information(self, 'HI')
        settings = QgsSettings()

        #self.settings.value('token'),

        if self.autopollCheckbox.isChecked() is False:
            if force is False:
                return


        self.resulttable.clearContents()
        apitoken = settings.value("lerplusdock/apitoken")
        if apitoken is None:
            return

        if force is True:
            self.updatenowButton.setText("Opdaterer...")

        pbox = self.getProgressBox("Snakker med lerplus server", "Henter data...")


        r = requests.get(API_URLBASE + '/getsessions?apitoken=' + apitoken)

        if not is_valid_json(r.text):
            QMessageBox.information(self, 'Invalid API-response', r.text)
            self.updatenowButton.setText("Tjek nu")
            return

        if inDebugMode():
            QMessageBox.information(self, 'API-response', r.text)

        if r.status_code != 200:
            self.updatelabel.setText("Sidst opdateret: fejl ved api-kald, 200")
            self.updatenowButton.setText("Tjek nu")
            return




       # if settings.value("lerplus/debugmode") == 1:
        #    QMessageBox.information(self, 'API-response', r.text)

        response = json.loads(r.text)
        if response['status'] != 'ok':
            if response['status'] == 'empty':
                self.resulttable.setItem(0, 0, QTableWidgetItem('Sidst opdateret: ingen tilgængelige besvarelser'))
                #self.updatelabel.setText("Sidst opdateret: ingen tilgængelige besvarelser")
            else:
                #self.resulttable.setItem(0, 0, QTableWidgetItem('Sidst opdateret: fejl ved api-kald, status!=ok/empty'))
                self.updatelabel.setText("Sidst opdateret: fejl ved api-kald, status!=ok/empty")
            return

        #self.updatelabel.setText("Sidst opdateret: " + datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        self.updatenowButton.setText("Tjek nu")
        if len(response['data']['sessions']) == 0:
            self.resulttable.setItem(0, 0, QTableWidgetItem('INgen sessions returneret'))
            return

        row = 0

        self.resulttable.setRowCount(0)

        pbox.setRange(0, len(response['data']['sessions']) + 1)

        count = 0


        buttons = {}
        for session in response['data']['sessions']:

            count += 1
            pbox.setValue(count)
            QApplication.processEvents()
            self.resulttable.insertRow(row)

            rowcount=0
            self.resulttable.setItem(row, rowcount, QTableWidgetItem(session['lerrespons']['Id']))


            rowcount += 1
            item = DateTableWidgetItem(session['dato'], session['datounix'])
            self.resulttable.setItem(row, rowcount, item)

            rowcount += 1
            self.resulttable.setItem(row, rowcount, QTableWidgetItem(session['lavetaf']))

            rowcount += 1
            self.resulttable.setItem(row, rowcount, QTableWidgetItem(session['statustext']))

            rowcount += 1
            self.resulttable.setItem(row, rowcount, QTableWidgetItem(session['slices']))





            ejercount = QTableWidgetItem(str(session['ejercount']))
            ejercount.setToolTip(str(session['ejernavnestring']))
            rowcount += 1
            self.resulttable.setItem(row, rowcount, ejercount)

            resultitem = QTableWidgetItem(str(session['ejerleveret']) + "/" + str(session['ejerforventet']))
            if session['ejerleveret'] == session['ejerforventet']:
                resultitem.setBackground(QColor(66, 245, 126))
            else:
                resultitem.setBackground(QColor(245, 66, 66))
            #resultitem.setToolTip(str(session['ejernavnestring']))

            rowcount += 1
            self.resulttable.setItem(row, rowcount, resultitem)

            rowcount += 1
            self.resulttable.setItem(row, rowcount, QTableWidgetItem(str(session['ejerudenom'])))

            rowcount += 1
            self.resulttable.setItem(row, rowcount, QTableWidgetItem(session['description']))


            #Importbutton
            bname = 'button' + session['lerrespons']['Id']
            # QMessageBox.information(self, 'SUCCESS! API-response', bname)
            buttons[bname] = QPushButton("Importér")
            buttons[bname].clicked.connect(partial(self.showResult, session['lerrespons']['Id']))
            rowcount += 1
            self.resulttable.setCellWidget(row, rowcount, buttons[bname])

            bname = 'kortbutton' + session['lerrespons']['Id']
            # QMessageBox.information(self, 'SUCCESS! API-response', bname)
            buttons[bname] = QPushButton("Vis i LER kortviser")
            # button =
            # buttons[bname].clicked.connect(lambda: self.showResult(session['lerrespons']['Id']))
            buttons[bname].clicked.connect(partial(self.showKortviser, session['lerrespons']['Id'], session['GUID']))
            rowcount += 1
            self.resulttable.setCellWidget(row, rowcount, buttons[bname])

            combo_box = QComboBox()
            combo_box.addItem("Select an option")  # Placeholder option
            combo_box.addItem("zip")
            combo_box.addItem("geojson")
            combo_box.addItem("geopackage")
            #combo_box.currentIndexChanged.connect(lambda index, row=row: self.on_option_selected(session['ssid'], row))
            combo_box.currentIndexChanged.connect(partial(self.downloadSession, session['ssid'], combo_box))

            combo_box.currentIndexChanged.connect(
                lambda index, combo_box=combo_box, row=row: self.on_option_selected(combo_box, row))
            rowcount+=1
            self.resulttable.setCellWidget(row, rowcount, combo_box)

            row = row + 1

        self.resulttable.resizeColumnsToContents()
        pbox.close()
        #self.resulttable.horizontalHeader().setStretchLastSection(True)
        return

    def downloadSession(self, ssid, combobox):
        token = get_download_token(self, ssid)
        if token is False:
            return
        #QMessageBox.information(self, 'token', token)
        type = combobox.currentText()

        url = 'https://backend.lerplus.dk/download/' + type + '/' + token
        qturl = QUrl(url)  # Replace with your desired URL
        QDesktopServices.openUrl(qturl)

    def showKortviser(self, lerid, guid):

        url = 'https://kortviser.ler.dk/?diggingRequestNr=' + lerid + '&ledningspakkeGuid=' + guid
        qturl = QUrl(url)  # Replace with your desired URL
        QDesktopServices.openUrl(qturl)

    def showResult(self, lerid):
        # QMessageBox.information(self, 'showresult', lerid)

        reply = QMessageBox.question(self, 'Afsendelse',
                                     'Er du sikker på du vil importere ledningsdata fra lerid=' + lerid + '?',
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.No:
            return

        settings = QgsSettings()
        token = settings.value("lerplusdock/apitoken")
        pbox=self.getProgressBox('Henter data', "Indlæser ledningsdata")
        r = requests.get(API_URLBASE + '/getpgresults?apitoken=' + token + '&lernr=' + lerid)
        # QMessageBox.information(self, 'ERROR! API-response', str(r.status_code))

        if not is_valid_json(r.text):
            QMessageBox.information(self, 'Invalid API-response', r.text)
            return

        if r.status_code != 200:
            QMessageBox.information(self, 'ERROR! API-response', str(r.status_codestr))

        if inDebugMode() is True:
            QMessageBox.information(self, 'SUCCESS! API-response', r.text)

        response = json.loads(r.text)

        # QMessageBox.information(self, '', json.dumps(response['data']['session']))
        groupname = response['data']['session']['description'] + ' (LERID ' + lerid + ')'
        schema = 'lerplus' + lerid

        connection_info = {
            'connectionName': groupname + ' connection',
            'host': 'backend.lerplus.dk',  # Replace with your PostGIS host
            'database': response['data']['pginfo']['dbname'],  # Replace with your database name
            'username': response['data']['pginfo']['username'],  # Replace with your PostGIS username
            'password': response['data']['pginfo']['password'],  # Replace with your PostGIS password
            'schema': schema,  # Replace with your schema name if not 'public'
            'table': 'your_table_name',  # Replace with your table name
            'geom_column': 'wkb_geometry'  # Replace with your geometry column name
        }

        # layer_group = QgsLayerTreeGroup(groupname)
        root = QgsProject.instance().layerTreeRoot()

        # eksisterer det allerede?
        layer_group = root.findGroup(groupname)

        if not layer_group:
            # ellers opret gruppen
            # layer_group = root.addGroup(groupname)
            layer_group = root.insertGroup(0, groupname)
        else:
            # Slet alle lag, så der opdateres i stedet
            for child in layer_group.children():
                if isinstance(child, QgsLayerTreeLayer):
                    QgsProject.instance().removeMapLayer(child.layerId())

        #bufferzoner = layer_group.addGroup("Bufferzoner")

        uri = QgsDataSourceUri()
        uri.setConnection(
            connection_info['host'],
            '5432',
            connection_info['database'],
            connection_info['username'],
            connection_info['password']
        )
        # uri_str=uri.uri()
        # QgsProject.instance().writeEntry("PostgreSQL/connections", groupname+' PG connection', uri_str)

        # styles_directory = os.path.join(os.path.dirname(__file__), 'styles')

        # Construct the absolute path to the file
        # sld_file_path = os.path.join(styles_directory, 'styles.sld')

        # = "styles/"
        # vandtest =  os.path.join(styles_directory, 'vandtest_qml.qml')
        # redtest = os.path.join(styles_directory, 'redtest.qml')
        # elledning = os.path.join(styles_directory, 'Elledning.qml')
        # redtest = "styles/redtest.qml"

        pbox.setRange(0,len(response['data']['tables'])+1)
        graveforesp_layer = ''
        count = 0
        for table in response['data']['tables']:
            count+=1
            pbox.setValue(count)
            QApplication.processEvents()

            if table['tablename'] == 'informationsressource':
                continue
            if table['tablename'] == 'kontaktprofil':
                continue
            if table['tablename'] == 'utilityowner':
                continue
            if table['tablename'] == 'utilitypackageinfo':
                continue

            uri.setDataSource(
                connection_info['schema'],
                table['tablename'],
                connection_info['geom_column'],
                ""
            )
            uri.setSrid('25832')

            # QMessageBox.information(self, 'Layer failed to load!', uri.uri())
            # Create a new PostGIS layer
            postgis_layer = QgsVectorLayer(uri.uri(), table['tablename'].capitalize(), 'postgres')

            # ler:" +

            if not postgis_layer.isValid():
                error_message = f"Layer '{table['tablename']}' failed to load!"
                QgsMessageLog.logMessage(error_message, 'PostGIS Layer Loader', Qgis.Critical)

                # Capture additional information about the error
                #error_message += f"\nURI: {uri.uri()}"
                #QgsMessageLog.logMessage(f"URI: {uri.uri()}", 'PostGIS Layer Loader', Qgis.Critical)

                #QMessageBox.information(self, 'Layer failed to load!', error_message)
                #QMessageBox.information(self, 'Layer failed to load!', 'dont know why' + table['tablename'])
                tis = 0
            else:
                # QMessageBox.information(self, 'Layer field names', ''.join(map(str, postgis_layer.fields().names())))

                if table['tablename'] == "graveforesp":
                    graveforesp_layer = postgis_layer
                    continue

                new_layer = QgsProject.instance().addMapLayer(postgis_layer, False)

                # with open(sld_file_path) as f:
                #                    lines = f.readlines()

                # new_layer.loadSldStyle(sld_file_path)

                if table['layerstyle'] != "":
                    temp = tempfile.NamedTemporaryFile('w')
                    tmpname = temp.name
                    temp.close()
                    tmpfile = open(tmpname, "w")
                    # kan skrive string fordi den ikke blev åbnet som binær (default open er 'w+b')
                    tmpfile.write(table['layerstyle'])
                    tmpfile.close()
                    # print(tmpname)
                    new_layer.loadNamedStyle(tmpname)

                    # clean up
                    os.remove(tmpname)
                    # QMessageBox.information(self, 'loadNamesStyle', type(table['layerstyle']))
                    # print(table['layerstyle'])

                if table['tablename'] == "elledning":
                    buffer_distance = 10  # Use the appropriate distance units for your data

                    # Create a buffer around the PostGIS layer
                    buffer_layer = QgsProcessingFeatureSourceDefinition(new_layer.id())
                    params = {
                        'INPUT': buffer_layer,
                        'DISTANCE': buffer_distance,
                        'SEGMENTS': 5,  # Number of segments to approximate curves in the buffer
                        'OUTPUT': 'memory:'
                        # You can also specify a file path if you want to save the buffer as a new layer
                    }

                    # Run the buffer algorithm
                    # processing.core.Processing.initialize()
                    result = processing.run("native:buffer", params)

                    # Access the resulting buffer layer
                    # buffered_layer = QgsProcessingFeatureSourceDefinition("memory:").source()
                    buffered_layer = result['OUTPUT']
                  #  print(type(buffered_layer))
                   # if buffered_layer:
                        # Add the buffered layer to the QGIS project
                        # QgsProject.instance().addMapLayer(buffered_layer)
                        #bufferzoner.addLayer(buffered_layer)
                  #  else:
                      #  print("Buffered layer not found in memory.")

                layer_group.addLayer(new_layer)
                # new_layer.loadNamedStyle(elledning)
                # style_manager.loadStyle(new_layer, sld_file_path)
                # style_manager = QgsMapLayerStyleManager(new_layer)
                # style_manager.loadFromString(lines)

                # Refresh the layer to see the changes
                # new_layer.triggerRepaint()
                self.iface.mapCanvas().refresh()
        pbox.close()

        if graveforesp_layer != '':
            # QMessageBox.information(self, 'getting to graveforesp!', 'dont know why')
            new_layer = QgsProject.instance().addMapLayer(graveforesp_layer, False)
            layer_group.addLayer(new_layer)
            QgsProject.instance().layerTreeRoot().findLayer(graveforesp_layer.id()).setItemVisibilityChecked(False)

        return

